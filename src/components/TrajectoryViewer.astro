---
// TrajectoryViewer.astro - Interactive component for viewing agent trajectories
---
<section id="data" class="content-section">
  <div class="section-container">
    <h2 class="section-title">Trajectory Viewer</h2>
    <p class="section-description">Explore agent trajectories across different tasks. View state transitions, LLM-generated actions, and the decision-making process.</p>
    
    <div class="trajectory-viewer">
      <!-- Task Selection -->
      <div class="task-selector">
        <label for="task-select">Select Task:</label>
        <select id="task-select" class="task-dropdown">
          <!-- Task options will be dynamically populated by JavaScript -->
        </select>
        
        <label for="trajectory-select" class="trajectory-label">Select Trajectory:</label>
        <select id="trajectory-select" class="trajectory-dropdown">
          <!-- Trajectory options will be dynamically populated by JavaScript -->
        </select>
      </div>
      
      <!-- Trajectory Timeline -->
      <div class="timeline-container">
        <div class="timeline">
          <div class="timeline-steps" id="timeline-steps">
            <!-- Timeline steps will be generated by JavaScript -->
            <div class="loading-indicator">
              <div class="spinner"></div>
              <p>Loading trajectory data...</p>
            </div>
          </div>
        </div>
        <div class="timeline-controls">
          <button id="prev-step" class="step-button" aria-label="Previous step">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
          </button>
          <span id="step-indicator" class="step-indicator">Step <span id="current-step">1</span> of <span id="total-steps">5</span></span>
          <button id="next-step" class="step-button" aria-label="Next step">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </button>
          <button id="play-pause" class="play-button" aria-label="Play trajectory">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="play-icon">
              <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="pause-icon" style="display: none;">
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
          </button>
        </div>
      </div>
      
      <!-- State and Action Display -->
      <div class="trajectory-display">
        <div class="state-container">
          <h3 class="display-subtitle">State</h3>
          <div class="state-content">
            <div class="state-image">
              <img id="state-image" src="/placeholder-state.png" alt="Current state" />
            </div>
            <div class="state-description">
              <p id="state-text">State description will appear here. This represents the environment's current state at the selected step.</p>
            </div>
          </div>
        </div>
        
        <div class="action-container">
          <h3 class="display-subtitle">LLM Action</h3>
          <div class="action-content">
            <div class="llm-reasoning">
              <h4>Reasoning:</h4>
              <div id="reasoning-text" class="code-block">
                <p>Let me think about the current state...</p>
                <p>I can see that the current position allows for multiple moves, but the most strategic one would be to...</p>
              </div>
            </div>
            <div class="llm-action">
              <h4>Action:</h4>
              <div id="action-text" class="code-block action-highlight">
                move_pawn('e2', 'e4')
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Trajectory Metrics -->
      <div class="metrics-container">
        <h3 class="display-subtitle">Trajectory Metrics</h3>
        <div class="metrics-grid">
          <div class="metric-card">
            <span class="metric-label">Success</span>
            <span id="success-value" class="metric-value success">Yes</span>
          </div>
          <div class="metric-card">
            <span class="metric-label">Total Steps</span>
            <span id="total-steps-value" class="metric-value">12</span>
          </div>
          <div class="metric-card">
            <span class="metric-label">Reasoning Score</span>
            <span id="reasoning-score" class="metric-value">8.7/10</span>
          </div>
          <div class="metric-card">
            <span class="metric-label">Time to Completion</span>
            <span id="completion-time" class="metric-value">14.3s</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<script>
  // This script will be client-side JavaScript for the TrajectoryViewer functionality
  document.addEventListener('DOMContentLoaded', () => {
    // Type definitions for trajectory data
    interface State {
      image: string;
      description: string;
    }
    
    interface Step {
      state: State;
      reasoning: string;
      action: string;
    }
    
    interface Trajectory {
      name: string;
      description: string;
      totalSteps: number;
      success: boolean;
      reasoningScore: string;
      completionTime: string;
      steps: Step[];
    }
    
    interface TaskData {
      taskName: string;
      taskDescription: string;
      trajectories: Record<string, Trajectory>;
    }
    
    interface Task {
      id: string;
      name: string;
      description: string;
      dataFile: string;
      thumbnail: string;
    }
    
    interface TaskIndex {
      version: string;
      lastUpdated: string;
      tasks: Task[];
    }
    
    // Trajectory viewer functionality
    // Element references
    const taskSelect = document.getElementById('task-select') as HTMLSelectElement;
    const trajectorySelect = document.getElementById('trajectory-select') as HTMLSelectElement;
    const timelineStepsContainer = document.getElementById('timeline-steps');
    const currentStepElement = document.getElementById('current-step');
    const totalStepsElement = document.getElementById('total-steps');
    const stateImageElement = document.getElementById('state-image') as HTMLImageElement;
    const stateTextElement = document.getElementById('state-text');
    const reasoningTextElement = document.getElementById('reasoning-text');
    const actionTextElement = document.getElementById('action-text');
    const successValueElement = document.getElementById('success-value');
    const totalStepsValueElement = document.getElementById('total-steps-value');
    const reasoningScoreElement = document.getElementById('reasoning-score');
    const completionTimeElement = document.getElementById('completion-time');
    const prevStepButton = document.getElementById('prev-step') as HTMLButtonElement;
    const nextStepButton = document.getElementById('next-step') as HTMLButtonElement;
    const playPauseButton = document.getElementById('play-pause') as HTMLButtonElement;
    
    // State variables
    let availableTasks: Task[] = [];
    let taskData: Record<string, TaskData> = {};
    let currentTaskId = '';
    let currentTrajectoryId = '';
    let currentStepIndex = 0;
    let isPlaying = false;
    let playInterval: number | null = null;
    
    // Display error message
    function showErrorMessage(message: string) {
      if (timelineStepsContainer) {
        timelineStepsContainer.innerHTML = `<div class="error-message">${message}</div>`;
      }
    }
    
    // Show loading indicator
    function showLoading() {
      if (timelineStepsContainer) {
        timelineStepsContainer.innerHTML = `
          <div class="loading-indicator">
            <div class="spinner"></div>
            <p>Loading trajectory data...</p>
          </div>
        `;
      }
    }
    
    // Load the task index
    async function loadTaskIndex() {
      try {
        showLoading();
        
        const response = await fetch('/data/trajectories/index.json');
        if (!response.ok) {
          throw new Error(`Failed to load task index: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json() as TaskIndex;
        availableTasks = data.tasks;
        
        // Populate task select dropdown
        if (taskSelect) {
          taskSelect.innerHTML = '';
          availableTasks.forEach(task => {
            const option = document.createElement('option');
            option.value = task.id;
            option.textContent = task.name;
            taskSelect.appendChild(option);
          });
          
          // Load the first task by default
          if (availableTasks.length > 0) {
            await loadTaskData(availableTasks[0].id);
          }
        }
      } catch (error) {
        console.error('Error loading task index:', error);
        showErrorMessage('Failed to load tasks. Please try again later.');
      }
    }
    
    // Load task data
    async function loadTaskData(taskId: string) {
      try {
        showLoading();
        
        // Find the task info
        const taskInfo = availableTasks.find(task => task.id === taskId);
        if (!taskInfo) {
          throw new Error(`Task with ID ${taskId} not found`);
        }
        
        // Load the task data file
        const response = await fetch(taskInfo.dataFile);
        if (!response.ok) {
          throw new Error(`Failed to load task data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json() as TaskData;
        taskData[taskId] = data;
        currentTaskId = taskId;
        
        // Populate trajectory select dropdown
        if (trajectorySelect) {
          trajectorySelect.innerHTML = '';
          
          Object.entries(data.trajectories).forEach(([id, trajectory]) => {
            const option = document.createElement('option');
            option.value = id;
            option.textContent = trajectory.name || id;
            trajectorySelect.appendChild(option);
          });
          
          // Load the first trajectory by default
          if (trajectorySelect.options.length > 0) {
            currentTrajectoryId = trajectorySelect.options[0].value;
            initializeTimeline();
          }
        }
      } catch (error) {
        console.error(`Error loading task data for ${taskId}:`, error);
        showErrorMessage(`Failed to load data for ${taskId}. Please try again later.`);
      }
    }
    
    // Initialize the timeline
    function initializeTimeline() {
      if (!timelineStepsContainer || !currentTaskId || !currentTrajectoryId) return;
      
      const currentTask = taskData[currentTaskId];
      if (!currentTask) return;
      
      const trajectory = currentTask.trajectories[currentTrajectoryId];
      if (!trajectory) return;
      
      const totalSteps = trajectory.steps.length;
      
      // Clear existing timeline steps
      timelineStepsContainer.innerHTML = '';
      
      // Add timeline progress bar
      const progressBar = document.createElement('div');
      progressBar.className = 'timeline-progress';
      progressBar.style.width = '0%';
      timelineStepsContainer.appendChild(progressBar);
      
      // Add step markers
      for (let i = 0; i < totalSteps; i++) {
        const step = document.createElement('div');
        step.className = 'timeline-step';
        step.style.left = `${(i / (totalSteps - 1)) * 100}%`;
        step.dataset.index = i.toString();
        
        step.addEventListener('click', () => {
          navigateToStep(i);
        });
        
        timelineStepsContainer.appendChild(step);
      }
      
      // Update step counter
      if (currentStepElement) currentStepElement.textContent = '1';
      if (totalStepsElement) totalStepsElement.textContent = totalSteps.toString();
      
      // Update metrics
      if (totalStepsValueElement) totalStepsValueElement.textContent = totalSteps.toString();
      if (successValueElement) {
        successValueElement.textContent = trajectory.success ? 'Yes' : 'No';
        successValueElement.className = trajectory.success ? 'metric-value success' : 'metric-value failure';
      }
      if (reasoningScoreElement) reasoningScoreElement.textContent = trajectory.reasoningScore || 'N/A';
      if (completionTimeElement) completionTimeElement.textContent = trajectory.completionTime || 'N/A';
      
      // Navigate to first step
      navigateToStep(0);
    }
    
    // Navigate to a specific step
    function navigateToStep(stepIndex: number) {
      if (!currentTaskId || !currentTrajectoryId) return;
      
      const currentTask = taskData[currentTaskId];
      if (!currentTask) return;
      
      const trajectory = currentTask.trajectories[currentTrajectoryId];
      if (!trajectory) return;
      
      const totalSteps = trajectory.steps.length;
      
      if (stepIndex < 0 || stepIndex >= totalSteps) {
        return;
      }
      
      currentStepIndex = stepIndex;
      const step = trajectory.steps[stepIndex];
      
      // Update step counter
      if (currentStepElement) currentStepElement.textContent = (stepIndex + 1).toString();
      
      // Update timeline UI
      if (timelineStepsContainer) {
        const steps = timelineStepsContainer.querySelectorAll('.timeline-step');
        const progressBar = timelineStepsContainer.querySelector('.timeline-progress') as HTMLElement;
        
        steps.forEach((stepEl, index) => {
          if (index < stepIndex) {
            stepEl.className = 'timeline-step completed';
          } else if (index === stepIndex) {
            stepEl.className = 'timeline-step active';
          } else {
            stepEl.className = 'timeline-step';
          }
        });
        
        // Update progress bar
        if (progressBar) {
          const progressPercentage = (stepIndex / (totalSteps - 1)) * 100;
          progressBar.style.width = `${progressPercentage}%`;
        }
      }
      
      // Update state and action display
      if (stateImageElement) stateImageElement.src = step.state.image || '/placeholder-state.png';
      if (stateTextElement) stateTextElement.textContent = step.state.description || '';
      if (reasoningTextElement) reasoningTextElement.innerHTML = `<p>${step.reasoning || ''}</p>`;
      if (actionTextElement) actionTextElement.textContent = step.action || '';
      
      // Update button states
      if (prevStepButton) prevStepButton.disabled = stepIndex === 0;
      if (nextStepButton) nextStepButton.disabled = stepIndex === totalSteps - 1;
    }
    
    // Play trajectory automatically
    function playTrajectory() {
      if (!currentTaskId || !currentTrajectoryId) return;
      
      const currentTask = taskData[currentTaskId];
      if (!currentTask) return;
      
      const trajectory = currentTask.trajectories[currentTrajectoryId];
      if (!trajectory) return;
      
      if (isPlaying) {
        if (playInterval !== null) {
          clearInterval(playInterval);
          playInterval = null;
        }
        
        const playIcon = playPauseButton?.querySelector('.play-icon') as HTMLElement;
        const pauseIcon = playPauseButton?.querySelector('.pause-icon') as HTMLElement;
        
        if (playIcon) playIcon.style.display = 'block';
        if (pauseIcon) pauseIcon.style.display = 'none';
        
        isPlaying = false;
      } else {
        playInterval = window.setInterval(() => {
          if (currentStepIndex < trajectory.steps.length - 1) {
            navigateToStep(currentStepIndex + 1);
          } else {
            if (playInterval !== null) {
              clearInterval(playInterval);
              playInterval = null;
            }
            
            const playIcon = playPauseButton?.querySelector('.play-icon') as HTMLElement;
            const pauseIcon = playPauseButton?.querySelector('.pause-icon') as HTMLElement;
            
            if (playIcon) playIcon.style.display = 'block';
            if (pauseIcon) pauseIcon.style.display = 'none';
            
            isPlaying = false;
          }
        }, 2000); // Advance every 2 seconds
        
        const playIcon = playPauseButton?.querySelector('.play-icon') as HTMLElement;
        const pauseIcon = playPauseButton?.querySelector('.pause-icon') as HTMLElement;
        
        if (playIcon) playIcon.style.display = 'none';
        if (pauseIcon) pauseIcon.style.display = 'block';
        
        isPlaying = true;
      }
    }
    
    // Initialize controls
    function initializeControls() {
      if (prevStepButton) {
        prevStepButton.addEventListener('click', () => {
          if (currentStepIndex > 0) {
            navigateToStep(currentStepIndex - 1);
          }
        });
      }
      
      if (nextStepButton) {
        nextStepButton.addEventListener('click', () => {
          if (!currentTaskId || !currentTrajectoryId) return;
          
          const currentTask = taskData[currentTaskId];
          if (!currentTask) return;
          
          const trajectory = currentTask.trajectories[currentTrajectoryId];
          if (!trajectory) return;
          
          if (currentStepIndex < trajectory.steps.length - 1) {
            navigateToStep(currentStepIndex + 1);
          }
        });
      }
      
      if (playPauseButton) {
        playPauseButton.addEventListener('click', playTrajectory);
      }
      
      if (taskSelect) {
        taskSelect.addEventListener('change', async (e) => {
          const target = e.target as HTMLSelectElement;
          await loadTaskData(target.value);
        });
      }
      
      if (trajectorySelect) {
        trajectorySelect.addEventListener('change', (e) => {
          const target = e.target as HTMLSelectElement;
          currentTrajectoryId = target.value;
          initializeTimeline();
        });
      }
    }
    
    // Initialize the trajectory viewer
    async function initializeTrajectoryViewer() {
      await loadTaskIndex();
      initializeControls();
    }
    
    // Initialize if the DOM elements exist
    if (taskSelect && trajectorySelect && timelineStepsContainer) {
      initializeTrajectoryViewer().catch(error => {
        console.error('Failed to initialize trajectory viewer:', error);
      });
    }
  });
</script> 